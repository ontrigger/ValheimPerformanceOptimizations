#include "Includes/OcclusionStructs.cginc"
#include "UnityCG.cginc"
#include "UnityDeferredLibrary.cginc"

//--------------------------------------------------------------------------------------
// Pragmas
//--------------------------------------------------------------------------------------

#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------
#define THREAD_GROUP_SIZE_X 32
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1

//--------------------------------------------------------------------------------------
// Constant Buffers
//--------------------------------------------------------------------------------------

cbuffer CB
{
    uint _ShouldOcclusionCull;
    uint _ShouldCullInvisible;
    
    /*int _ShadowCascades;
    float _ShadowDistance;
    float _DetailCullingScreenPercentage;*/
    float2 _HiZTextureSize;
    float3 _CamPosition;

	float4 _CullingPlanes[6];
    
    float4x4 _UNITY_MATRIX_MVP;
    Texture2D _HiZMap;
    SamplerState sampler_HiZMap;
};

//--------------------------------------------------------------------------------------
// Structured Buffers
//--------------------------------------------------------------------------------------

StructuredBuffer<InstanceData> _InstanceDataBuffer;
RWStructuredBuffer<VisibilityData> _VisibilityBuffer;

//--------------------------------------------------------------------------------------
// Kernels & Functions
//--------------------------------------------------------------------------------------
#if UNITY_REVERSED_Z    // DX
# define MIN_DEPTH(l, r) max(l, r)
# define MAX_DEPTH(l, r) min(l, r)
#else                   // opengl
# define MIN_DEPTH(l, r) min(l, r)
# define MAX_DEPTH(l, r) max(l, r)
#endif

inline float GatherMaxDepth4PointInDepthBuffer(float2 minXY, float2 maxXY, uint mip)
{
	float4 boxUVs = float4(minXY, maxXY);
	float4 depth = float4(
		Linear01Depth(_HiZMap.SampleLevel(sampler_HiZMap, boxUVs.xy, mip).r),
		Linear01Depth(_HiZMap.SampleLevel(sampler_HiZMap, boxUVs.zy, mip).r),
		Linear01Depth(_HiZMap.SampleLevel(sampler_HiZMap, boxUVs.xw, mip).r),
		Linear01Depth(_HiZMap.SampleLevel(sampler_HiZMap, boxUVs.zw, mip).r)
	);

	return MIN_DEPTH(MIN_DEPTH(depth.x, depth.y), MIN_DEPTH(depth.z, depth.w));
}

inline uint IsCameraOutsideObjBounds(float3 pos, float3 minPos, float3 maxPos)
{
    float boundsSize = distance(maxPos, minPos);
    return ((distance(pos, maxPos) > boundsSize)
            + (distance(pos, minPos) > boundsSize));
}

//The depth is linear, the range is [0, 1]
inline uint isCascadeVisibleFromDepth(float clipMinZ, float depth)
{
	return (clipMinZ) < depth + 0.000001 ? 1 : 0; // last is an epsilon
}

// Hi-Z Culling
inline uint isVisibleInDepthBuffer(float3 clipMin, float3 clipMax)
{
    // Change it to 0 - 1 range 
	float2 minXY = float2(clipMin.x, clipMin.y) * 0.5f + 0.5f;
	float2 maxXY = float2(clipMax.x, clipMax.y) * 0.5f + 0.5f;
	/*minXY = clamp(minXY, 0, 1);
	maxXY = clamp(maxXY, 0, 1);*/
    
	// Calculate hi-Z buffer mip
	int2 size = (maxXY - minXY) * _HiZTextureSize.xy;
	int mip = ceil(log2(max(size.x, size.y)));
    mip = clamp(mip, 0, 12);
    
    // Texel footprint for the lower (finer-grained) level
    float  level_lower = max(mip - 1, 0);
    float2 scale = exp2(-level_lower);
    float2 a = floor(minXY * scale);
    float2 b = ceil(maxXY * scale);
    float2 dims = b - a;
    
    // Use the lower level if we only touch <= 2 texels in both dimensions
    if (dims.x <= 2 && dims.y <= 2)
    {
        mip = level_lower;
    }

	float maxDepth = GatherMaxDepth4PointInDepthBuffer(minXY, maxXY, mip);
	
	if (isCascadeVisibleFromDepth(clipMin.z, maxDepth) < 1 && mip > 1)
	{
		maxDepth = GatherMaxDepth4PointInDepthBuffer(minXY, maxXY, mip - 1);
	}

	if (isCascadeVisibleFromDepth(clipMin.z, maxDepth) < 1 && mip > 2)
	{
		maxDepth = GatherMaxDepth4PointInDepthBuffer(minXY, maxXY, mip - 2);
	}
	
    return isCascadeVisibleFromDepth(clipMin.z, maxDepth);
}

inline uint IsVisibleAfterFrustumCulling(float4 clipPos)
{
    return (clipPos.z > clipPos.w 
            || clipPos.x < -clipPos.w 
            || clipPos.x > clipPos.w 
            || clipPos.y < -clipPos.w 
            || clipPos.y > clipPos.w) 
            ? 0 : 1;
}

inline uint CalculateMinMaxWithLinearZ(float4 corner[8], float4x4 matrixVP, out float3 outClipMin, out float3 outClipMax)
{
	float4 clipPos = mul(matrixVP, corner[0]);
	clipPos.xy = clipPos.xy / clipPos.w;
	clipPos.z = clipPos.w * _ZBufferParams.w;
	
	float clipMinX = clipPos.x;
	float clipMaxX = clipPos.x;
	float clipMinY = clipPos.y;
	float clipMaxY = clipPos.y;
	float clipMinZ = clipPos.z;
	float clipMaxZ = clipPos.z;
	
	[unroll]
	for (int i = 1; i < 8; i++)
	{ 
		clipPos = mul(matrixVP, corner[i]);
		// For Frustum
		//isInFrustum = saturate(isInFrustum + FrustumCulling(clipPos));
		// For HiZ
		clipPos.xy = clipPos.xy / clipPos.w;
		clipPos.z = clipPos.w * _ZBufferParams.w;
		
		clipMinX = min(clipPos.x, clipMinX);
		clipMaxX = max(clipPos.x, clipMaxX);
		clipMinY = min(clipPos.y, clipMinY);
		clipMaxY = max(clipPos.y, clipMaxY);
		clipMinZ = min(clipPos.z, clipMinZ);
		clipMaxZ = max(clipPos.z, clipMaxZ);
	}
	
	outClipMin.x = clipMinX;
	outClipMin.y = clipMinY;
	outClipMin.z = clipMinZ;
	outClipMax.x = clipMaxX;
	outClipMax.y = clipMaxY;
	outClipMax.z = clipMaxZ;
	return 1;
}


uint FrustumCullingEx(float3 center, float3 extent)
{
	for (int i = 0; i != 6; ++i)
	{
		float3 normal = _CullingPlanes[i].xyz;
		float distance = dot(normal, center) + _CullingPlanes[i].w;
		float radius = dot(extent, float3(abs(normal.x), abs(normal.y), abs(normal.z)));
		if (distance + radius < 0)
			return 0;
	}
	return 1;
}

//--------------------------------------------------------------------------------------
// Kernels
//--------------------------------------------------------------------------------------
float LOD00_RANGE = 15;
float LOD01_RANGE = 50;

int _Count;
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 _dispatchThreadID : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex, // uint GroupIndex = unique index of a thread inside a group
        in uint3 _groupID          : SV_GroupID, // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadID    : SV_GroupThreadID // uint3 GroupThreadId = indices for each dimension inside a group of the current thread
    )
{
    // Calculate the instance index
    uint tID = _dispatchThreadID.x;
    if (tID >= (uint)_Count)
    {
        return;
    }

    uint wasVisible = _VisibilityBuffer[tID].isVisible;
	if (_ShouldCullInvisible + wasVisible < 1)
	{
		return;
	}

    // Get the instance data
    InstanceData instance = _InstanceDataBuffer[tID];

    // Check if the instance is visible
    float3 minPos = instance.boundsCenter - instance.boundsExtents;
    float3 maxPos = instance.boundsCenter + instance.boundsExtents;

    float4 boxCorners[8];
    boxCorners[0] = float4(minPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[1] = float4(minPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[2] = float4(minPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[3] = float4(minPos.x, maxPos.y, maxPos.z, 1.0);
    boxCorners[4] = float4(maxPos.x, minPos.y, minPos.z, 1.0);
    boxCorners[5] = float4(maxPos.x, minPos.y, maxPos.z, 1.0);
    boxCorners[6] = float4(maxPos.x, maxPos.y, minPos.z, 1.0);
    boxCorners[7] = float4(maxPos.x, maxPos.y, maxPos.z, 1.0);

    uint isVisible = FrustumCullingEx(instance.boundsCenter, instance.boundsExtents);

	float3 clipMin, clipMax;
	CalculateMinMaxWithLinearZ(boxCorners, _UNITY_MATRIX_MVP, clipMin, clipMax);

    //float minDistanceToCamera = distance(instance.boundsCenter.xyz, _CamPosition.xyz);

    // We only cull instances where the camera doesn't intersect the instance 
    // bounds. If the camera is inside the bounds we want to render the object
    if (IsCameraOutsideObjBounds(_CamPosition, minPos, maxPos))
    {
    	isVisible *= isVisibleInDepthBuffer(clipMin, clipMax);
    }

	VisibilityData visData;
	visData.instanceId = instance.instanceId;
	visData.isVisible = isVisible; // | (wasVisible << 1);
	
    // Output
    _VisibilityBuffer[tID] = visData;
}